---
id: cyphal-can
title: Cyphal CAN
sidebar_label: Cyphal CAN 
sidebar_position: 1
description: Работа с Cyphal
---


## Зачем нужен Cyphal 

В современных робототехнических и встраиваемых системах редко используется только один микроконтроллер. Чаще всего проект состоит из нескольких устройств: контроллеров моторов, датчиков, управляющего компьютера (например, Raspberry Pi) и других модулей. Все эти устройства должны обмениваться данными между собой.

Для такой связи часто используется шина **CAN (Controller Area Network)** — надёжный и широко распространённый протокол, специально созданный для работы в реальном времени и в условиях помех. Во многих микроконтроллерах, например в STM32G4, уже есть встроенный аппаратный модуль **FDCAN**, что делает CAN удобным выбором для построения сети устройств.

Однако у CAN есть важное ограничение: он работает **только с наборами байтов**. Сам по себе CAN не знает, что именно передаётся — скорость мотора, угол поворота, команда или ошибка. Разработчику приходится вручную договариваться:
    - какие байты что означают,
    - как их упаковывать и распаковывать,
    - как обрабатывать ошибки и версии сообщений.

По мере усложнения системы такой подход становится неудобным, сложным в поддержке и легко приводит к ошибкам.

**Что даёт Cyphal**

Для решения этой проблемы был выбран протокол [**Cyphal**](https://opencyphal.org/).
Он работает поверх CAN (в том числе FDCAN) и добавляет удобный уровень абстракции, не жертвуя скоростью и надёжностью. Cyphal позволяет:
    - передавать структурированные сообщения, а не просто байты;
    - отправлять данные произвольной длины, а не ограничиваться небольшими кадрами CAN;
    - чётко описывать формат данных (например: скорость, направление, состояние);
    - легко организовывать связь между микроконтроллерами и компьютером (например, Raspberry Pi).

Проще говоря, с Cyphal разработчик работает не с «сырыми байтами», а с понятными сообщениями, что делает код чище, проект — надёжнее, а систему — легче в развитии и отладке.

## Основная идея Cyphal

По своей идее Cyphal очень похож на ROS, только предназначен не для компьютеров, а для микроконтроллеров и CAN-шины. В Cyphal вся система состоит из нод (nodes) — отдельных устройств в сети. Нодой может быть:
    - микроконтроллер,
    - плата управления мотором,
    - датчик,
    - компьютер (например, Raspberry Pi).

Каждая нода выполняет свою задачу и **обменивается сообщениями с другими нодами**. 

## Топики и обмен сообщениями
Обмен данными в Cyphal происходит через топики (topics), так же как в ROS. **Топик** — это «канал связи» с определённым типом данных. Одна нода может **публиковать** данные в топик, другая нода может **подписываться** на этот топик и получать данные.
Например: 
    - нода мотора публикует свой текущий статус;
    - управляющая нода отправляет команды скорости;
    - компьютер подписывается на данные диагностики.

При этом нодам не нужно знать друг о друге напрямую — они просто работают с топиками. Это делает систему гибкой и удобной для расширения. 
**Чем это лучше обычного CAN**
Cyphal берёт на себя всю «рутинную» работу:
    - упаковку и разбиение данных на CAN-кадры;
    - сборку сообщений обратно;
    - контроль типов данных и их формата.

В итоге разработчик работает с **понятными сообщениями**, а не с набором байтов, и может думать о логике работы системы, а не о деталях передачи данных.

:::info
Несмотря на то, что Cyphal старается быть удобным и понятным, это серьёзный протокол со своей логикой и правилами. Описание всего протокола выходит за рамки этой докуменации.  Поэтому при работе с ним обязательно нужно читать [**официальную спецификацию**](https://specification.opencyphal.org/Cyphal_Specification.pdf). Спецификация объясняет:
    - как устроены ноды и топики;
    - какие бывают сообщения и сервисы;
    - как правильно строить сеть устройств.

Даже если вы только учитесь, привычка обращаться к спецификации — это важный навык инженера и программиста.
:::
